#get object or 404 will help with the exception
from django.shortcuts import render, get_object_or_404

#raise http404
from django.http import Http404
# Create your views here.
from django.http import HttpResponse, HttpResponseRedirect
# this is important to use with template
from django.template import loader

from django.urls import reverse

from .models import Question, Choice

from django.views import generic

from django.utils import timezone

#this is a simple version that using HttpResponse
# path('', views.index, name='index'),
#  path('<int:question_id>/' , views.detail, name='detail'),
#  path('<int:question_id>/results', views.results, name='results'),
#  path('<int:question_id>/vote/',views.vote, name='vote'),
# def index(request):
#     return HttpResponse("Hello, world. You're at the polls index.")


# def index(request):
#   latest_question_list = Question.objects.order_by('-pub_date')[:5]
#   output = ', '.join([q.question_text for q in latest_question_list])
#   return HttpResponse(output)

# def detail(request, question_id):
#   return HttpResponse("You 're looking at question %s." %question_id)

# def results(request, question_id):
#   response = "You 're looking at the results of question %s."
#   return HttpResponse(response% question_id)

# def vote(request, question_id):
#   return HttpResponse("You 're voting on question %s." % question_id)



#here is the version that it is using templates

# def index(request):
#   latest_question_list = Question.objects.order_by('-pub_date')[:5]

#   # template = loader.get_template('polls/index.html')
#   # context is dictionary mapping template variable names to python object
#   context = { 'latest_question_list' : latest_question_list,}
#   # return httpresponse with template loader but the common way doing it is by return the render
#   # return HttpResponse( template.render(context,request))
#   return render(request, 'polls/index.html', context)


# def detail(request,question_id):
#   # try:
#   #   question = Question.objects.get(pk=question_id)
#   # except Question.DoesNotExist:
#   #   raise  Http404('Question does not exist')
#   #short version
#   question = get_object_or_404(Question, pk=question_id)
#   # there is also a get_list_or_404() function, which works just as get_object_or_404()-except using filter() instead of get(). it raises http404 if list is empty
#   return render(request, 'polls/detail.html', { 'question': question})

def vote(request, question_id):
    question= get_object_or_404(Question,pk=question_id)
    try:
      selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except(KeyError, Choice.DoesNoExist):
      # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
          'question': question,
          'error_message': "You didn't select a choice.",
        })
    else:
      selected_choice.votes +=1
      selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.

        # should always return an HttpResponseRedirect after dealing with POST data

      # reverse() helps avoid having to hardcode a URL in the view function
      return HttpResponseRedirect(reverse('polls:results', args=(question_id,)))

# def results(request, question_id):
#   question = get_object_or_404(Question, pk=question_id)
#   return render(request, 'polls/results.html', {'question': question})


# generic way view with urls
# urlpatterns = [
#      path('', IndexView.as_view(), name='index'),
#      path('<int:pk>/' , views.DetailView.as_view(), name='detail'),
#      path('<int:pk>/results', views.ResultsView.as_view(), name='results'),
#      path('<int:question_id>/vote/',views.vote, name='vote'),
# ]



#ListView: display a list of objects
#DetailVieww: display a detail page for particular type of object
# need mdoel attribute
#DetailView generic view expects the pk value capture from the url to called 'pk' so we change question_id to pk
#default: the DV use a template called <app name>/<model name>_detail.html so in this case, it would be use thetemplate "polls/question_detail.html". The template_name attr is used to tell django to use a specific template name instead of the autogenerated default template name We also specify the template_name for the results list view – this ensures that the results view and the detail view have a different appearance when rendered, even though they’re both a DetailView behind the scenes.

# Similarly, the ListView generic view uses a default template called <app name>/<model name>_list.html; we use template_name to tell ListView to use our existing "polls/index.html" template.

# For DetailView the question variable is provided automatically – since we’re using a Django model (Question), Django is able to determine an appropriate name for the context variable. However, for ListView, the automatically generated context variable is question_list. To override this we provide the context_object_name attribute, specifying that we want to use latest_question_list instead. As an alternative approach, you could change your templates to match the new default context variables – but it’s a lot easier to just tell Django to use the variable you want.

class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
      # return the last five published question
      # return Question.objects.order_by('-pub_date'[:5])
      # using filter
      # Question.objects.filter(pub_date__lte=timezone.now()) returns a queryset containing Questions whose pub_date is less than or equal to - that is, earlier than or equal to - timezone.now.
      return Question.objects.filter(pub_date__lte=timezone.now() ).order_by('-pub_date')[:5]

class DetailView(generic.DetailView):
  template_name = 'polls/detail.html'
  def get_queryset(self):
    """
    Excludes any questions that aren't published yet.
    """
    return Question.objects.filter(pub_date__lte=timezone.now())

class ResultsView(generic.DetailView):
  model = Question
  template_name = 'polls/results.html'